<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Serial Plotter v1.0</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        canvas { max-width: 100%; }
        button { padding: 10px; margin: 10px; }
        .chart-container { display: flex; flex-direction: column; align-items: center; }
    </style>
</head>
<body>
    <h1>Real-Time Serial Data Plot v1.0</h1>
    <button id="connectButton">Connect to Serial</button>
    <button id="recordButton">Start Recording</button>
    <button id="downloadButton">Download CSV</button>
    <p id="status">Status: Not Connected</p>
    
    <div class="chart-container">
        <canvas id="rollChart"></canvas>
        <canvas id="pitchChart"></canvas>
        <canvas id="forceChart"></canvas>
    </div>
    
    <script>
        let port;
        let reader;
        let keepReading = false;
        let recording = false;
        let csvData = [['Timestamp', 'Roll (째)', 'Pitch (째)', 'Force (N)']];
        const maxSamples = 2000;
        
        const labels = [];
        const rollData = [];
        const pitchData = [];
        const forceData = [];
        
        function createChart(ctx, label, color) {
            return new Chart(ctx, {
                type: 'line',
                data: { labels: labels, datasets: [{ label: label, data: [], borderColor: color, fill: false }] },
                options: { responsive: true, scales: { x: { title: { display: true, text: 'Time (s)' } }, y: { title: { display: true, text: 'Values' } } } }
            });
        }
        
        const rollChart = createChart(document.getElementById('rollChart').getContext('2d'), 'Roll (째)', 'blue');
        const pitchChart = createChart(document.getElementById('pitchChart').getContext('2d'), 'Pitch (째)', 'red');
        const forceChart = createChart(document.getElementById('forceChart').getContext('2d'), 'Force (N)', 'green');
        
        document.getElementById('connectButton').addEventListener('click', async () => {
            try {
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: 115200 });
                document.getElementById('status').innerText = 'Status: Connected';
                keepReading = true;
                readSerial();
            } catch (error) {
                console.error('Error connecting to serial:', error);
            }
        });
        
        async function readSerial() {
            const textDecoder = new TextDecoderStream();
            const readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
            reader = textDecoder.readable.getReader();
            
            while (keepReading) {
                try {
                    const { value, done } = await reader.read();
                    if (done) break;
                    processSerialData(value.trim());
                } catch (error) {
                    console.error('Serial read error:', error);
                    document.getElementById('status').innerText = 'Status: Disconnected';
                    keepReading = false;
                    break;
                }
            }
            reader.releaseLock();
        }
        
        function processSerialData(data) {
            const lines = data.split('\n').map(line => line.trim()).filter(line => line.startsWith('DATA'));
            lines.forEach(line => {
                try {
                    const parts = line.split(',');
                    if (parts.length !== 5) return;
                    const [, roll, pitch, force, timestamp] = parts.map(item => item.trim());
                    if (isNaN(roll) || isNaN(pitch) || isNaN(force) || isNaN(timestamp)) return;
                    
                    const timeInSeconds = parseInt(timestamp) / 1000.0;
                    labels.push(timeInSeconds.toFixed(1));
                    rollData.push(parseFloat(roll));
                    pitchData.push(parseFloat(pitch));
                    forceData.push(parseFloat(force));
                    
                    if (recording) csvData.push([timestamp, roll, pitch, force]);
                    if (labels.length > maxSamples) {
                        labels.shift(); rollData.shift(); pitchData.shift(); forceData.shift();
                    }
                    
                    rollChart.data.labels = labels;
                    rollChart.data.datasets[0].data = rollData;
                    pitchChart.data.labels = labels;
                    pitchChart.data.datasets[0].data = pitchData;
                    forceChart.data.labels = labels;
                    forceChart.data.datasets[0].data = forceData;
                    rollChart.update();
                    pitchChart.update();
                    forceChart.update();
                } catch (error) {
                    console.error('Error parsing data:', error);
                }
            });
        }
        
        document.getElementById('recordButton').addEventListener('click', () => {
            recording = !recording;
            document.getElementById('recordButton').innerText = recording ? 'Stop Recording' : 'Start Recording';
        });
        
        document.getElementById('downloadButton').addEventListener('click', () => {
            if (csvData.length > 1) {
                const csvContent = csvData.map(row => row.join(',')).join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `M5Stack_data_${Date.now()}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }
        });
    </script>
</body>
</html>
